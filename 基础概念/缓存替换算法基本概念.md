## LRU-最近最少使用替换算法
设计原理：
LRU 算法的核心思想是“如果一个数据在最近一段时间没有被使用，那么它在未来被使用的可能性也很小”。因此，它会优先淘汰最近最少使用的数据。

实现方式：
- 数据结构：通常使用一个**双向链表**来记录数据的访问顺序，结合一个 **哈希表** 来实现数据的快速查找。
- 工作流程：
	1. 当访问一个数据项时，首先通过哈希表查找其在链表中的位置。
	2. 如果命中，将该数据项从链表中移除，并将其移动到链表头部。
	3. 如果未命中，创建一个新的数据项，将其添加到链表头部。
	4. 如果缓存已满，则将链表尾部的数据项（即最近最少使用的）移除。
- 优点：
	- **命中率高：** 基于“时间局部性”原理，能有效预测未来访问的数据，通常具有较高的命中率。
	- **概念直观：** 原理简单易懂，易于实现。
- 缺点：
	- **开销大：** 每次访问都需要更新链表，无论是命中还是未命中，都有移动操作。在高并发场景下，需要复杂的同步机制来保证数据一致性。

## FIFO (First In, First Out)
设计原理：
FIFO 算法的原则是“先进入缓存的数据先被淘汰”。它将缓存看作一个先进先出的队列，最先进入的数据项被认为是最旧的，也最应该被替换。

实现方式：
- **数据结构：** 通常使用一个**队列**来管理数据项。
- 工作流程：
	- 新数据项进入时，添加到队列尾部。
	- 如果缓存已满，直接淘汰队列头部的数据项。
- 优点：
	- **实现简单：** 不需要额外记录访问时间或频率，实现成本低。
	- 开销小：替换操作的开销很小，非常适合资源受限的环境。
- 缺点：
	- **命中率低：** 无法反映数据的访问频率或时间局部性。一个被频繁使用的数据项，如果它进入缓存的时间最早，也可能会被淘汰，导致“异常”现象（Belady's Anomaly）。

## CLOCK
设计原理：
CLOCK 算法是 LRU 的一个近似实现，它试图在保持较高命中率的同时，降低 LRU 的实现开销。它用一个环形队列来管理数据，并为每个数据项设置一个“使用位”（use bit）。

实现方式：
- **数据结构：** 一个**环形队列**，每个节点有一个**使用位**（通常是 1 或 0）。
- 工作流程：
	- 新数据项被添加到环形队列中。
	- 当访问一个数据项时，将其**使用位设置为 1**。
	- 当需要淘汰数据时，一个“时钟指针”会从当前位置开始扫描：
		- 如果遇到使用位为 1 的数据项，将其**使用位清零（置为 0）**，并继续扫描下一个。
		- 如果遇到使用位为 0 的数据项，则淘汰该数据项，并将新数据项放入该位置。
- 优点：
	- **性能优于 FIFO：** 通过使用位反映了数据的“新旧”程度，避免了 FIFO 的一些缺点
	- **开销小：** 相比 LRU，CLOCK 算法避免了链表频繁移动的开销，实现更简单，性能更高。
- 缺点：
	- **命中率低于 LRU：** 它只是 LRU 的一个近似，无法精确地反映数据的访问顺序。
	- **“使用位”粒度粗：** 只能表示数据是否被使用过，无法区分最近被使用和很久以前被使用。

## SIEVE
设计原理：
SIEVE 算法是 CLOCK 算法的一种变体，也使用一个环形队列和“使用位”，但在淘汰策略上有所不同。它通过一个指针扫描环形队列，对使用位进行操作。

实现方式：
- **数据结构：** 和 CLOCK 类似，一个**FIFO队列**，每个节点有**使用位**。
- 工作流程：
	- 当需要淘汰数据时，一个指针从当前位置开始扫描环形队列。
	- 扫描过程中，如果遇到使用位为 1 的节点，就将使用位清零。
	- 继续扫描，直到找到一个使用位为 0 的节点，然后淘汰该节点。
	- 如果一圈扫描下来所有节点的使用位都是 1，那么就淘汰第一个遇到的节点。
- 优点：
	- **性能优于 CLOCK：** 避免了 CLOCK 算法在扫描时可能重复将使用位为 1 的节点再次扫描的问题。
	- **实现简单：** 与 CLOCK 类似，开销小。
- 缺点：
	- **命中率低于 LRU：** 同样是 LRU 的一个近似，命中率不如 LRU 精确。

## LRU和CLOCK的差异化
LRU淘汰最长时间未被访问的缓存项
Clock通过一个“指针”循环扫描缓存项，利用一个访问位（reference bit）决定是否淘汰。

LRU维护一个**双向链表**，缓存被访问时把对应节点移动到链表头；淘汰时移除链表尾部节点。访问时需要频繁调整链表。精确保证淘汰的是最长时间未访问的项。

Clock将缓存项按环形链表，每个缓存项有一个**访问位**（reference bit），初始为0。访问缓存时，将访问位设为1。淘汰时，指针顺时针扫过缓存项：若访问位为1，重置为0，跳过（给予第二次机会）；若访问位为0，则淘汰该项，指针指向下一项继续。

## CLOCK与SIEVE的差异化
1. 指针移动方式：
	1. **Clock 算法**：它的名字来源于“时钟”。算法使用一个环形链表，指针就像时钟的秒针一样，永远**单向前进**。当它遇到一个最近被访问过的项时，会清除其访问位，并将其重新**移动到链表头部**。这确保了该项获得“第二次机会”，可以再次被时钟指针检查。
	2. **Sieve 算法**：Sieve 指针的移动方式更像是一个“筛子”。它在链表上**来回折返**。当它从一端移动到另一端时，会清除一路上所有被访问过的项的访问位。一旦到达末尾，它会立即跳到另一端继续。它给被访问过的项“第二次机会”的方式是**不移动它们的位置**，而是仅仅清除访问位，让指针继续前进，这简化了链表操作。
2. 淘汰策略：
	1. **Clock**：当时钟指针遇到一个被访问过的项，它会**移动**该项。这个移动操作虽然开销不大，但在极高并发下仍可能成为瓶颈。
	2. **Sieve**：当 Sieve 指针遇到一个被访问过的项时，它**不会移动该项**，只是简单地清除访问位，然后继续前进。只有当它遇到一个未被访问过的项时，才会将其移除。这种不移动节点的策略是 Sieve 算法的一个关键优势，它能显著减少链表操作的开销，尤其是在并发环境中。