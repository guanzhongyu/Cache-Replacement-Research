## 算法级实现
对于高并发场景下的缓存替换算法，性能瓶颈之一是互斥锁的资源消耗。
这里首先实现一个最基础的线程安全的FIFO替换算法：使用全局互斥锁，unordered_set提供常数级查找缓存
```C++
#include <iostream>
#include <queue>
#include <unordered_set>
#include <mutex>
#include <thread>
#include <vector>

class ThreadSafeFIFOCache
{
public:
    ThreadSafeFIFOCache(size_t capacity) : capacity_(capacity) {}

    // 访问缓存数据
    bool access(int key)
    {
        std::lock_guard<std::mutex> lock(mutex_);

        // 缓存命中
        if (cacheSet_.count(key))
        {
            std::cout << "Cache hit: " << key << std::endl;
            return true;
        }

        // 缓存未命中，替换
        if (cacheQueue_.size() == capacity_)
        {
            int oldest = cacheQueue_.front();
            cacheQueue_.pop();
            cacheSet_.erase(oldest);
            std::cout << "Evict: " << oldest << std::endl;
        }

        cacheQueue_.push(key);
        cacheSet_.insert(key);
        std::cout << "Cache miss, insert: " << key << std::endl;
        return false;
    }

private:
    size_t capacity_;                  // 缓存容量大小
    std::queue<int> cacheQueue_;       // 维护FIFO顺序
    std::unordered_set<int> cacheSet_; // 快速判断是否存在缓存
    std::mutex mutex_;                 // 保护共享数据
};

// 模拟并发访问
void worker(ThreadSafeFIFOCache &cache, const std::vector<int> &requests)
{
    for (int key : requests)
    {
        cache.access(key);
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

int main()
{
    ThreadSafeFIFOCache cache(3);

    // 两个线程模拟不同访问请求
    std::thread t1(worker, std::ref(cache), std::vector<int>{1, 2, 3, 4, 1});
    std::thread t2(worker, std::ref(cache), std::vector<int>{2, 5, 1, 6});

    t1.join();
    t2.join();

    return 0;
}

```
在main函数中定义了容量大小为3的缓存池，两个线程模拟并行访问。

## AtomicFIFOHashTable
- Folly是Facebook开源的一个C++库，适用于多线程、高并发和大数据处理的场景
- folly::DistributedMutex是一种高性能的分布式锁（互斥锁），用于保护多线程访问共享资源时的数据安全。
- `std::unique_lock<Mutex>`自动加锁和解锁，保证锁的安全释放。

### 静态成员变量
负载因子的倒数，用于控制哈希表的扩容阈值
static constexpr size_t loadFactorInv_{2};
每个桶可以存储的最大条目数
static constexpr size_t nItemPerBucket_{8};
用于计算桶索引的掩码
static constexpr size_t bucketIdxMask_{0xFFFFFFFFFFFFFFF8};
键和值的掩码，
constexpr static uint64_t keyMask_ = 0x00000000FFFFFFFF;
constexpr static uint64_t valueMask_ = 0xFFFFFFFF00000000;
哈希表的桶数量
size_t numElem_{0};
FIFO队列的最大容量
size_t fifoSize_{0};
原子计数器，记录总插入的条目数
  std::atomic<int64_t> numInserts_{0};
原子计数器，记录总淘汰的条目数
  std::atomic<int64_t> numEvicts_{0};
哈希表的存储数组，每个元素时uint64_t
  alignas(64) std::unique_ptr<uint64_t[]> hashTable_{nullptr};
线程安全锁，保护哈希表的并发访问
  `mutable folly::cacheline_aligned<Mutex> mtx_;`

**mutabel mtx_线程安全锁** ：
folly::cacheline_aligned确保锁独占一个缓存行，避免与其他变量伪共享。
mutable允许在const方法中加锁（例如查询）
### 静态成员函数
size_t getBucketIdx(uint32_t key)
计算桶索引。
(size_t)key % numElem_ 通过取模运算将 `key` 映射到 `[0, numElem_ - 1]` 的范围内。

**计算桶索引，匹配值Key，截取时间戳，打包键key和值time存储到哈希表中**。

### 公共函数
构造函数explicit AtomicFIFOHashTable(uint32_t fifoSize) noexcept
explicit关键字：防止该构造函数被隐式转换调用，避免意外的类型转换。
noexpect：说明该函数不会抛出异常。
获得**参数fifoSize**，计算哈希表的总容量

void initHashtable() noexcept
**初始化哈希表**，std::move转让所有权

### 查询和插入
查询：
`__atomic_load_n`，原子加载内存值，保证并行安全性。

`__atomic_compare_exchange_n`原子比较交换函数
```C++
bool __atomic_compare_exchange_n(
    type* ptr,           // 要修改的内存地址（比如 &hashTable[i]）
    type* expected,      // 你预期的值（同时用于接收实际值）
    type desired,        // 想要设置的新值
    bool weak,           // 是否允许"虚假失败"（通常用 true）
    int success_order,   // 成功时的内存序（如 __ATOMIC_RELEASE）
    int failure_order    // 失败时的内存序（如 __ATOMIC_ACQUIRE）
);
```
原子级的“先检查再修改”，`expected`输入时是你认为当前应该的值，输出时如果比较失败，会被更新为实际值。

**查询时被动清理FIFO队列**，遍历FIFO队列匹配是否存在键key，同时计算每个元素的插入时间戳，当前时间戳 - 插入时间戳 > fifosize时，清理旧值。

*实现过程*：先清理过期条目，然后匹配键key
存在情况：匹配到key之前因为条目过期导致匹配失败，返回false

性能优先，此外，“过期即无效”从业务上看也是合理的。

插入：
```C++
for (size_t i = 0; i < nItemPerBucket_; i++) {
        uint64_t valInTable = __atomic_load_n(&hashTable_[bucketIdx + i], __ATOMIC_RELAXED);
        if (valInTable == 0) {
            if (__atomic_compare_exchange_n(&hashTable_[bucketIdx + i], &valInTable,
                                            hashTableVal, true, __ATOMIC_RELAXED,
                                            __ATOMIC_RELAXED)) {
                return;
            }
        }
    }
```

比较读取时和修改时两者的一致性，从而确保在整个修改过程中没有其他线程争用该内存。

**问题**：如果“插入”过程中存在其他线程争用该内存，放弃该内存插入，继续向后搜索插入新的内存。
最后没有找到空白内存，随机写入覆盖。

### 锁竞争处理
`LockHolder l(*mtx_);`
相比较之前的对函数加锁，各并行线程竞争锁资源，现在的版本使用__atomic_compare_exchange_n和__atomic_store_n等原子操作保证并行安全性，去掉锁竞争。

### 隐式FIFO队列：时间戳窗口
FIFO队列没有设计实例，只定义了fifosize窗口大小。
插入查询操作时，哈希表的元素根据存活时间判断是否过期。
该设计**避免了维护FIFO队列**，适合高并发、低延时的缓存系统。

## 思考
1. AtomicFIFOHashTable::contains查询函数，采用了**先清理后查询**的设计思路。
这种设计是否符合业务需求，是否降低了**查询命中率**，过期即失效。

2. `LockHolder l(*mtx_);`对函数操作加锁
这种设计与我自己写的FIFO替换算法一致，属于全局互斥锁设计，各种进程对锁的争用大大降低了缓存替换算法的性能。
使用__atomic_load_n和__atomic_compare_exchange_n原子操作，*先取值在比较*，确保整个写入过程中不会被其他进程影响。

3. **​基于时间戳范围的虚拟FIFO​**​设计，用全局时间戳 `numInserts_` 和固定时间窗口 `fifoSize_` 模拟FIFO行为，无需物理队列。
潜在问题：时间戳`numInserts_`超过32位整型后，简单处理为0；
淘汰不均匀，未查询到空白位置时，随机插入，可能占用待使用条目。

4. loadFactorInv_负载因子的倒数
哈希表物理大小 = numElem_ = fifoSize_ * loadFactorInv_
保证哈希表稀疏性，在查询函数里有被动清理逻辑，
在遍历桶的每个元素时同步的判断是否数据过期。

`numEvicts_` 仅统计主动淘汰条目，不计入被动清理的条目数