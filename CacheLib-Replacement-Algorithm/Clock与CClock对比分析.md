CLOCK 和 CCLOCK 都属于近似 LRU（Least Recently Used）缓存淘汰算法，它们共享以下核心设计思想：
1. **侵入式链表（Intrusive List）**: 两种算法都依赖于一个侵入式双向链表来组织缓存项。每个缓存对象内部都嵌入了一个 `Hook` 结构，用于存储链表指针。这种设计减少了内存开销，并提高了内存局部性。
2. **访问位机制（Reference Bit）**: 它们都使用一个标记位来记录缓存项是否被访问过。当缓存空间不足时，算法会遍历链表，通过检查这个标记来决定哪些项可以被淘汰，从而避免了每次访问都移动链表节点的昂贵操作。

CCRCLOCK 在 CLOCK 的基础上，针对**高并发和大规模缓存**场景，在以下几个方面做出了显著改进：
1. 并发处理：

>CLOCK主要依赖std::atomic进行无锁更新，但对于复杂操作还是使用`folly::DistributedMutex`等互斥锁来保护临界区。锁的粒度相对较粗，一个线程加锁时会阻塞其他所有操作，可能成为高并发场景的瓶颈。

>CCLOCK尽可能避免使用互斥锁。通过 **`__atomic_compare_exchange_n`** 等原子操作，以及多状态标记和批量处理，实现了更细粒度的无锁并发。
>通过原子状态机和分段处理，将锁的粒度降至最低，允许多个线程并行地执行淘汰逻辑，从而实现了更高的吞吐量。

2. 淘汰策略：
	1. CCLOCK中的多个缓存项替换函数设计了多种替换策略：
		1. 批量处理，一次性获取一段链表进行处理。
		2. **多状态机**: 引入了一个三态的 `state_` 变量（`CC_UNMARK`、`CC_MOVABLE`、`CC_EVICTABLE`）。这使得并发线程可以更精细地协调状态，例如一个线程将一个项标记为 `EVICTABLE`，另一个线程就知道它正在被处理，从而避免冲突。
3. 链表存储：
	1. `CClockListHook` 结构体只包含一个 `next_` 指针，而没有 `prev_` 指针，这正是单向链表的特征：
		1. **内存效率**: 由于每个节点少了一个 `prev_` 指针，每个缓存项可以节省一个指针大小的内存。
		2. **并发安全**: 单向链表在并发操作时，对尾部的追加和头部的移除通常更简单、更安全。

