## 缓存的基础概念
缓存是用于存储经常访问的数据的**高速存储层**。当程序需要访问数据时，它首先在缓存中查找。如果数据存在（**缓存命中**），就直接返回，这比从底层存储（如数据库）中获取数据快得多。如果数据不存在（**缓存未命中**），程序则从底层存储中获取数据，并将其放入缓存，以便下次访问时更快。

- 优点：
	- **提升性能：** 减少数据访问延迟，缩短响应时间。
	- **降低负载：** 减轻数据库和后端服务的压力。
	- **提高吞吐量：** 在有限的硬件资源下处理更多的请求。
- 缺点
	- **数据一致性：** 缓存中的数据和数据库中的数据可能不一致。
	- 成本：内存通常比磁盘贵，缓存需要额外的硬件或资源。
	- **复杂性：** 引入缓存会增加系统的复杂性，需要考虑缓存的更新、淘汰等问题。

## 缓存的分类
- 按部署位置分：
	- 本地缓存 (Local Cache)：缓存数据存储在应用程序的内存中，如使用 `ConcurrentHashMap` 或 `Guava Cache`。它的优点是访问速度极快，但缺点是容量有限，并且在分布式系统中存在数据一致性问题。
	- **分布式缓存 (Distributed Cache)：** 缓存数据存储在独立的缓存服务器集群中，如 **Redis** 和 **Memcached**。优点是容量大，支持多台服务器共享，易于扩展，解决了分布式系统中的一致性问题。缺点是网络开销比本地缓存高。
- 按数据类型分：
	- **读缓存 (Read Cache)：** 主要用于加速读取操作。大部分请求是读请求，写请求较少时适用。
	- **读缓存 (Read Cache)：** 主要用于加速读取操作。大部分请求是读请求，写请求较少时适用。

## 缓存常见的架构模式
- Cache-Aside (旁路缓存)：
	- 读操作：
		1. 先查询缓存。
		2. 如果命中，直接返回
		3. 如果未命中，查询数据库。
		4. 将数据库中的数据放入缓存，并返回。
	- 写操作：
		1. 先更新数据库，再删除缓存（**这是最常见的**，也叫先写数据库后删缓存）
		2. 为什么不先更新数据库，再更新缓存？因为更新操作不是原子的，可能会导致**数据库和缓存数据不一致**。
	- 优点：简单实用，大多数场景适用。
	- 缺点：首次访问数据时会未命中，需要访问数据库，会有延迟。
- Read-Through / Write-Through (读穿透 / 写穿透)：
	- **读穿透：** 应用程序只与缓存交互。当缓存未命中时，由缓存系统自己去数据库中加载数据，然后返回给应用。
	- **写穿透：** 应用程序只与缓存交互。当写入数据时，缓存系统将数据写入自身，并同步更新到数据库。
	- **优点：** 应用程序代码简单，不需要关心缓存和数据库的同步问题。
	- **缺点：** 实现了缓存和数据库同步逻辑，增加了缓存系统的复杂性。
- Write-Behind (写回 / 异步写)：
	- 应用程序只与缓存交互，将数据写入缓存。
	- 缓存系统**异步地**将数据写入数据库。
	- **优点：** 写入速度非常快，因为是异步写入。
	- **缺点：** 如果缓存系统在数据同步到数据库之前宕机，可能会导致**数据丢失**。

## 缓存中常见问题与解决方案
### 缓存雪崩
操作分布式缓存和操作数据库，这两个操作很难保证原子性。
缓存雪崩(Cache Avalanche)是指在一个时间段内，**大量缓存同时过期**。此时，大量的请求都未命中缓存，全部涌向数据库，导致数据库被压垮。
- 解决办法：
	- **过期时间随机化：** 为每个缓存的过期时间添加一个**随机值**，使得它们不会在同一时间过期。
	- **多级缓存：** 引入多级缓存，例如本地缓存和分布式缓存结合，即使分布式缓存失效，本地缓存也能在一定程度上抵挡流量。
	- **限流降级：** 当数据库压力过大时，启用**限流**或**降级**策略，保证核心业务的可用性

### 缓存穿透
**缓存穿透（Cache Penetration）​**​ 是指频繁查询一个​**​不存在的数据​**​，导致请求​**​绕过缓存​**​直接访问数据库，造成数据库压力过大甚至崩溃的现象。
- 解决方案：
	- **缓存空对象Null**：如果查询结果为空，也在缓存中存储一个**空值**（如 null），并设置一个较短的过期时间。下次再查询时，就会命中这个空值，不再访问数据库。
	- **布隆过滤器(Bloom Filter)**：在写入缓存前，使用布隆过滤器判断请求的数据是否存在。如果过滤器判断不存在，就直接返回，不查询缓存和数据库。
		- 缺点：布隆过滤器（简单哈希）的删除困难，不同的Key可能占据相同的哈希位，过滤器和数据库操作如何保证原子性？

### 缓存击穿
**缓存击穿（Cache Breakdown）​**​ 是指一个**热点**数据在缓存中**过期**的瞬间，同时有大量的并发请求访问该数据。这些请求都会未命中缓存，导致所有请求都涌向数据库，造成数据库压力骤增。
解决方案：
- 互斥锁（分布式锁）：当一个请求发现缓存过期时，它会获取一个**互斥锁**。其他请求则在锁上等待。获得锁的请求负责从数据库加载数据并放入缓存，之后释放锁。
	- 存在的问题：拿不到锁的进程阻塞；实际应用不能这样设计，高并发的进程阻塞可能导致过载。
	- 解决办法：拿不到锁的请求返回一个默认值，在Key-value中加一个字段：逻辑过期的时间。每个请求首先判断是否过期，如果过期了再去抢分布式锁，拿不到锁的请求直接返回这个逻辑过期时的内容，这是*弱一致性*的体现。

## 设计需求
短时间内同时有大量用户请求访问系统，需要系统能够*快速、稳定的*提供服务。
- 高性能
- 高可用：必须由某个集群提供服务。

## 系统拆分
- 前后端资源分离：静态资源部署到CDN，用户从最近的节点加载，减轻主服务器的负担
- 动静数据分离：静态数据长时间缓存、动态数据实时获取，90%的数据无需反复请求。
- 高低频接口分离：读取接口设计轻量，写接口承担更复杂的逻辑。

## 削峰限流
- 客户端限流：验证码方案分散用户请求
- 服务端限流：分布式限流和单机限流结合
- 限流算法：计数器、漏桶、令牌桶算法。

## 快速响应
多级缓存：本地缓存、中心化缓存、热点数据、数据预热。

## 数据一致性
缓存与数据库一致性：先更新数据库再删除缓存
本地与中心缓存一致性
重要数据一致性：数据库事务或分布式锁，确保只有一个事务能够修改缓存

## 稳定性
服务隔离：高并发服务独立部署
数据库隔离
全方位监控